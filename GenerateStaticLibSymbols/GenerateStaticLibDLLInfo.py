import os
from stat import *
import sys
import time
import string
import time

DEBUG = False

# Global Vars
SourceDirectories = []
OutputFilePath = ""
ValidCall = False
OutputFile = ""

print "Running GenerateStaticLibDLLInfo:"

if DEBUG:
    for arg in sys.argv:
        print arg
    SourceDirectories.append("SOMETHING")   
    OutputFile = "SOMETHING/SOMETHING.cpp"
    ValidCall = True
else:
    if len(sys.argv) > 2:
        ValidCall = True
        OutputFile = sys.argv[1]
        for i in range (2, len(sys.argv)):
            if os.path.isdir(sys.argv[i]):
                SourceDirectories.append(sys.argv[i])
            else:
                ValidCall = False
                print "ERROR: Invalid Directory in Argument " + str(i) + ".\n"
                print "       Directory : " + sys.argv[1]
                break
    else:
        print "ERROR: Invalid Number of Arguments"
    if not ValidCall:
        print """USAGE: <OutputFilePath> <Dir1> <Dir2> ...
NOTE: If your directory or file path contains a space, it requres an "".
      If your path ends in an "\" and contains a space you must add an
      additional \ to correct a Windows Bash bug. This is particularly
      important in VS2005 as the $(InputDir) contains a trailing \"
      use "$(InputDir)\" instead of "$(InputDir)"
 """
def ParseFolders(dirpath, filelist, extension):
    if not os.path.isdir(dirpath):
        print 'DIR INPUT: ' + dirpath + ' IS EPIC FAIL!!!'
        return
#    print dirname
    for fname in os.listdir(dirpath):
        if os.path.isdir(dirpath + "\\" + fname):
            ParseFolders(dirpath + "\\" + fname, filelist, extension)
        if fname.lower().endswith(extension):
            filelist.append(dirpath + "\\" + fname)
    return filelist

def ParseFoldersForFiles(dirpath, filelist, extension):
    if not os.path.isdir(dirpath):
        print 'DIR INPUT: ' + dirpath + ' IS EPIC FAIL!!!'
        return
    for fname in os.listdir(dirpath):
        if os.path.isdir(dirpath + "\\" + fname):
            ParseFoldersForFiles(dirpath + "\\" + fname, filelist, extension)
        if fname.lower().endswith(extension):
            filelist.append(dirpath + "\\" + fname)
    return filelist
    
def ParseLine(line):
    if "//" in line:
        preseperator, seperator, partline = line.partition(" ")
        partline = partline.strip()
        partline = partline.strip("{")
        partline = partline.strip()
        partline = partline.strip("=")
        partline = partline.strip()
        return True, partline
    return False, line

def ParseDLLInfoLine(line):
    if "INITDLLINFO" in line:
        tokens = line.split(" ")
        if len(tokens) >= 3:
            tokens = tokens[1].split("_")
            if len(tokens) >= 2 and "INITDLLINFO" in tokens[1]:
                return True, tokens[0].strip()
    return False, line
    
def ParseFileForDLLInfo(filepath, parsedmessages):
    if not os.path.isfile(filepath):
        print 'FILE INPUT: ' + filepath + ' IS EPIC FAIL!!!'
        return
    F = open(filepath)
    FLines = F.readlines()
    F.close()
    for line in FLines:
        returnval, returnline = ParseDLLInfoLine(line)
        if returnval:
            parsedmessages.append(returnline)
    return parsedmessages

def GenerateOutputFile(DLLInfoList, FileName):
    FileLines = []
    filetime = time.strftime("%x %X", time.localtime() )
    FileLines.append("//Autogenerated Static Lib File:\n")
    FileLines.append("//Generated by : " + sys.argv[0] + " @" + filetime + "\n\n")

    FileLines.append("#include \".\\" + FileName + ".h\"\n\n")
 	 	
    FileLines.append("//External definitions\n")
    
    for token in DLLInfoList:
        partline = "#ifdef INCLUDE_SYMBOLS_" + token + "\nextern struct INITDLLINFO " + token + "_INITDLLINFO;\n#endif\n"
        FileLines.append(partline)
 	
    FileLines.append("//DLL Info Array:\nINITDLLINFO *g_vStaticLibInitDLLInfo[] = {\n")
    for token in DLLInfoList:
        partline = "#ifdef INCLUDE_SYMBOLS_" + token + "\n\t&" + token + "_INITDLLINFO,\n#endif\n"
        FileLines.append(partline)
        
    FileLines.append("\tNULL\n")
    FileLines.append("};\n")
 
    return FileLines

def WriteFile(filepath, FLines):
#    if not os.path.isfile(filepath):
#        print 'FILE OUTPUT: ' + filepath + ' IS EPIC FAIL!!!'
#        return
    F = open(filepath, 'w')
    F.writelines(FLines)
    F.close()

if ValidCall:
    FileList = []
    for directory in SourceDirectories:
        ParseFoldersForFiles( directory, FileList, '.gen' )

    DefineLists = []
    NameList = []
    bInvalidGen = False
    ParsedDLLInfo = []
	
    for File in FileList:
        cppFileList = []
        PluginPath, PluginFile = os.path.split( os.path.abspath(File) )
        #print "Parse Plugin Directory"
        ParseFoldersForFiles( PluginPath, cppFileList, '.cpp' )
        for cppFile in cppFileList:
            ParseFileForDLLInfo(cppFile, ParsedDLLInfo)

    FilePath, FileName = os.path.split(OutputFile)
    FileNameBase = FileName.split(".")
    FileOutput = GenerateOutputFile(ParsedDLLInfo, FileNameBase[0])
    WriteFile( OutputFile, FileOutput )
